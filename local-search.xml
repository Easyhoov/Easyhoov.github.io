<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机基础</title>
    <link href="/2023/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%801.0/"/>
    <url>/2023/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%801.0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>是控制硬件和支持软件运行的计算机程序，向下<strong>控制硬件</strong>向上<strong>支持软件的运行</strong>，具有承上启下的作用</p><p>服务器中的CentOS一般不用图形化界面的原因：</p><ul><li><p>图形化界面占用资源比命令行多得多，为了节约资源</p></li><li><p>图形化界面大多数时候没有命令行效率高</p></li></ul><p>Windows是单用户操作系统，而Linux是多用户操作系统，支持多用户同时登录</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>由于每台电脑的用户名不同、操作系统版本不同、手动安装等原因，一些系统目录的路径也不完全相同，但是可以用变量快速打开，这些变量称为环境变量。</p><p>环境变量可以帮助有需要的程序找到所需要的文件的位置，例如：编写C&#x2F;C++代码时，在链接的时候，一般不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。</p><h1 id="CPU架构"><a href="#CPU架构" class="headerlink" title="CPU架构"></a>CPU架构</h1><p>central processing unit ，中央处理器</p><p>常见英语缩写</p><table><thead><tr><th>Esc</th><th>escape 退出</th></tr></thead><tbody><tr><td>Tab</td><td>tabulator 跳格键</td></tr><tr><td>Ctrl</td><td>control 控制</td></tr><tr><td>Alt</td><td>alternative 交替，换挡</td></tr><tr><td>Del</td><td>delete 删除</td></tr><tr><td>Ins</td><td>insert 插入</td></tr></tbody></table><h1 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h1><p>有这么一个公式：程序&#x3D;数据结构+算法。</p><p>C语言中一般使用面向过程编程，就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步调用，在函数中对数据结构进行处理(执行算法)，也就是说数据结构和算法是分开的。</p><p>C++语言把数据和算法封装在一起，形成一个整体，无论是对它的属性进行操作、还是对它的行为进行调用，都是通过一个对象来执行，这就是面向对象编程思想。</p><p>面向对象的语言有c++，python，java等。面向对象的语言，主要关注的重点是对象，而不是过程。面向对象的语言是采用对象、类及其相关概念进行的一些程序设计，在操作运用方面更为简单方便。面向对象的语言的语法和语义更明白易懂。</p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是<strong>利用更多的机器，处理更多的数据</strong></p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能</p><h1 id="字符介绍"><a href="#字符介绍" class="headerlink" title="字符介绍"></a>字符介绍</h1><ul><li><p><strong>字符(Character)</strong> 是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p></li><li><p><strong>字符集(Character set)</strong> 是一个系统支持的所有抽象字符的集合。通常以二维表的形式存在，二维表的内容和大小是由使用者的语言而定。如ASCII,GBxxx,Unicode等。</p></li><li><p><strong>字符编码(Character encoding)</strong> 是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。每个字符集中的字符都对应一个唯一的二进制编码。</p></li></ul><p>字符集和字符编码一般都是成对出现的，如ASCII、IOS-8859-1、GB2312、GBK，都是即表示了字符集又表示了对应的字符编码。Unicode比较特殊，有多种字符编码（UTF-8,UTF-16等）</p><p>常见字符集&amp;编码</p><ul><li><p><strong>GB 2312</strong> 或 <strong>GB 2312–80</strong> 是中华人民共和国国家标准简体中文字符集，共收录6763个汉字，基本满足了汉字的计算机处理需要</p></li><li><p><strong>GBK</strong> 汉字内码拓展规范，GBK的K表示Kuo Zhan（扩展），共收入汉字（包括部首和构件）21003 个 。</p></li><li><p><strong>Unicode</strong>（<strong>万国码</strong>、<strong>国际码</strong>、<strong>统一码</strong>）一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为<strong>Unicode转换格式</strong>（Unicode Transformation Format，简称为UTF）。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。</p><ul><li><p><strong>UTF-8</strong>（<strong>8-bit Unicode Transformation Format</strong>）是一种针对Unicode的可变长度字符编码</p><ol><li><p>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。</p></li><li><p>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。</p></li><li><p>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。</p></li><li><p>其他极少使用的Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）。</p></li></ol></li></ul></li></ul><p><strong>ANSI编码</strong>：并不是某个确定的字符编码，而是ASCII码的延伸编码（ 如GB2312、GBK、GB18030、Big5、Shift_JIS）的总称。在简体中文Windows操作系统中，ANSI 编码代表 GB2312编码；在繁体中文Windows操作系统中，ANSI编码代表Big5</p><h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><p>二维码本身就是一个URL，只是通过QR（Quick Response）码的形式把URL和用户身份信息转换成二进制的0和1，二维码中黑色的色素块代表1，白色的色素块代表0，我们通过扫码，就获取了二维码中的URL</p><p><strong>错误修正容量</strong></p><p>L水平 7% 的字码可被修正</p><p>M水平 15% 的字码可被修正</p><p>Q水平 25% 的字码可被修正</p><p>H水平 30% 的字码可被修正</p><h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><p>Node.js发布于2009年5月，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I&#x2F;O模型，  让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言</p><p>简单的说 Node.js 就是运行在服务端的 JavaScript</p><h1 id="常见缩写"><a href="#常见缩写" class="headerlink" title="常见缩写"></a>常见缩写</h1><p>SNS（Social Networking Service）社交网络服务</p><p>O2O（Online To Offline）即在线离线&#x2F;线上到线下，是指将线下的商务机会与互联网结合，让互联网成为线下交易的平台</p><p>B2B（也有写成 BTB，是Business-to-Business的缩写）是指企业与企业之间通过专用网络或Internet，进行数据信息的交换、传递，开展交易活动的商业模式</p><p>B2C（Business-to-Client）是指电子商务的一种模式，也是直接面向消费者销售产品和服务商业的零售模式</p><p>SVN是subversion的缩写，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理</p><p>SEO是英文 Search Engine Optimization 的缩写，中文意思“搜索引擎优化”。SEO是指在了解搜索引擎自然排名机制的基础上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中的关键词自然排名，从而获得更多流量，最终达成品牌建设或者产品销售的目的</p><p>sku产品规格</p><p>ERP：（Enterprise Resource Planning）企业资源计划，ERP是针对物资资源管理(物流)、人力资源管理(人流)、财务资源管理(财流)、信息资源管理(信息流)集成一体化的企业管理软件</p><p>OA：（Office Automation）办公自动化，是将现代化办公和计算机技术结合起来的一种新型的办公方式</p><h1 id="YAML语法格式"><a href="#YAML语法格式" class="headerlink" title="YAML语法格式"></a>YAML语法格式</h1><ol><li><p>大小写敏感</p></li><li><p>使用缩进表示层级关系</p></li><li><p>不支持Tab键制表符缩进，只使用空格缩进</p></li><li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可，通常开头缩进两个空格</p></li><li><p>字符后缩进一个空格，如冒号，逗号，短横杆（-)等</p></li><li><p>“—“表示YAML格式，一个文件的开始，用于分隔文件间</p></li><li><p>“#”表示注释</p></li></ol><p>yaml 中的值有以下基本类型：字符串、整形、浮点型、布尔型、null、时间、日期</p><ul><li><p>破折号和空格( “****” )：Lists集合</p></li><li><p>冒号和空格( “****” ) ：Maps键值对</p></li><li><p>井号（ “****” ）：注释</p></li><li><p>三个破折号( “****” ）：文档内容分隔线（多用于文档开始的地方）</p></li><li><p>三个冒号( “****” ）：表示文档的结束</p></li><li><p>锚点（“<strong><strong>”），重复项抛锚（“</strong></strong>”）：两者成对表达，像定义变量a，再引用变量a的关系，是一种重复项的替换</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>接口测试-jmeter</title>
    <link href="/2021/06/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-jmeter/"/>
    <url>/2021/06/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-jmeter/</url>
    
    <content type="html"><![CDATA[<h1 id="接口测试-jmeter"><a href="#接口测试-jmeter" class="headerlink" title="接口测试-jmeter"></a>接口测试-jmeter</h1><h1 id="什么是Jmeter"><a href="#什么是Jmeter" class="headerlink" title="什么是Jmeter"></a>什么是Jmeter</h1><p>Apache JMeter是Apache组织开发的基于java的压力测试工具</p><p>适用的测试领域</p><ul><li><p>对软件做压力测试。可用于测试静态和动态资源，例如：静态文件、Java小程序、CGI脚本、Java对象、数据库、FTP服务器等等。模拟巨大的负载，来自不同压力类别下测试它们的强度和整体性能</p></li><li><p>对应用程序做功能、回归测试，通过创建带有断言的脚本来验证程序返回的结果是否符合期望。允许使用正则表达式创建断言</p></li><li><p>接口测试</p></li><li><p>数据库压力测试</p></li><li><p>批量产生测试数据</p></li></ul><h1 id="jmeter元件"><a href="#jmeter元件" class="headerlink" title="jmeter元件"></a>jmeter元件</h1><p><strong>作用域</strong></p><p>所有组件都会作用于它的父级、同级、同级组件的子组件</p><p><strong>执行顺序</strong></p><p>在同一个作用域范围内，元件按照以下顺序执行：</p><ol><li><p>测试计划：jmeter的起点和容器</p></li><li><p>线程组：代表一定的虚拟用户</p></li><li><p>配置元件：请求期的配置信息</p></li><li><p>前置处理器：在请求之前的操作</p></li><li><p>定时器：是否延迟或间隔发送请求</p></li><li><p>取样器：发送请求的最小单元</p></li><li><p>后置处理器：在请求之后的操作</p></li><li><p>断言：判断请求的响应是否与需求一致</p></li><li><p>监听器：负责收集测试结果</p></li></ol><p>同一元件的组件一般按上下顺序运行，但是也有例外，如配置元件”用户定义的变量”无论它处于测试树的哪个位置，总是在测试的最开始执行</p><h1 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h1><p>线程执行的顺序：</p><p><img src="/image/image_-0799Jqa11.png"></p><p>如果勾选了独立运行每个线程组，则按上下顺序运行；如果没有勾选，则同时运行</p><p>setUP线程组：在所有线程组之前运行，如果有多个都是等价的</p><p>普通线程组</p><p>tearDown线程组：在所有线程组之后运行，如果有多个都是等价的</p><h1 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h1><p>使用变量代替值，称为参数化，也叫数据驱动</p><p>变量的引用方式为 ${变量名}</p><p><strong>参数化的作用：</strong></p><ol><li><p>参数化可以方便有大量请求不同测试数据时的接口测试，例如有100组请求参数数据，如果一个个在请求取样器中更改效率就会很低，而参数化后，看放在csv文件中，一次性执行完成；</p></li><li><p>对于要多次用到的参数值，参数化可以方便修改，例如在自定义用户变量定义某个变量A后，在多个请求中都用到了此变量，如果需要改变参数值，可以直接修改变量A的值，而不必在用到此变量的请求中去更改；</p></li><li><p>对于自动化接口测试，参数化更是必须的</p></li></ol><h1 id="配置元件"><a href="#配置元件" class="headerlink" title="配置元件"></a>配置元件</h1><h2 id="CSV数据文件设置"><a href="#CSV数据文件设置" class="headerlink" title="CSV数据文件设置"></a>CSV数据文件设置</h2><p>用于从文件中读入大量测试数据依次赋值给变量，并进行测试</p><ul><li><p>在最外层的线程组（默认叫线程组，可以改名字）中设置循环次数为数据的个数</p><p><img src="/image/image-20220225124235196_o8pB-r7yrk.png"></p></li></ul><p><img src="/image/image_xtQ2nq4X8G.png"></p><ul><li><p>可用txt格式的文件，要使用分隔符</p></li><li><p>也可用csv格式文件，csv是表格形式的文件，可用表格编辑软件打开，编辑起来更方便直观</p></li></ul><h2 id="http信息头管理器"><a href="#http信息头管理器" class="headerlink" title="http信息头管理器"></a>http信息头管理器</h2><ul><li><p>放在http请求下面时只会显示所属的http请求的信息头</p></li><li><p>放在线程组下时对所有http请求生效</p></li></ul><p>常用情景：</p><ul><li><p>需要token</p></li><li><p>请求体传参数时，请求体要使用content-type:application&#x2F;json</p></li></ul><h2 id="http请求默认值"><a href="#http请求默认值" class="headerlink" title="http请求默认值"></a>http请求默认值</h2><ul><li>不填http数据时生效，填了以填写的为准</li></ul><h2 id="HTTP-Cookie管理器"><a href="#HTTP-Cookie管理器" class="headerlink" title="HTTP Cookie管理器"></a>HTTP Cookie管理器</h2><p>cookie鉴权原理：</p><p>客户端第一次访问服务器的，服务器会生成Cookie，然后通过响应头中的Set-Cookie传输到客户端，然后保存在客户端中；第2次以上访问时，同过请求头中的Cookie把我们保存在本地的Cookie信息传输到服务以实现鉴权</p><p>Cookie管理器的作用：</p><ol><li><p><strong>Cookie 管理器就像一个 web 浏览器那样存储并发送 cookie</strong></p><p>如果 HTTP 请求的返回结果里包含 cookie，那么 Cookie 管理器会自动将该 cookie 保存起来，而且以后所有的对该网站的请求都使用此 cookie。每个 JMeter 线程都有自己独立的”cookie 保存区域”。注意这些 cookie 不会显示在 Cookie 管理器里，可以通过察看结果树来对其进行查看</p></li><li><p><strong>接收到的 cookie 数据可以作为 Jmeter 线程的参数进行存储</strong></p><p>要将 cookie 存储为参数，定义属性”CookieManager.save.cookies&#x3D;true”。cookie 在被保存之前会在名字上加上 “COOKIE_” 前缀(避免和本地参数重复)。设置好一会名字为 TEST 的 cookie 可以用 ${COOKIE_TEST} 进行引用。如果不希望这个前缀可以对属性 “CookieManager.name.prefix&#x3D;” 进行定义&amp;#x20;</p></li><li><p><strong>手动添加一个 cookie 到 Cookie 管理器</strong></p><p>&amp;#x20;手动添加的cookie 将被所有 JMeter 线程所共享。这种方式用于创建有很长过期日期的 cookie</p></li></ol><h2 id="用户定义的变量"><a href="#用户定义的变量" class="headerlink" title="用户定义的变量"></a>用户定义的变量</h2><p><img src="/image/image_zsPCctS5oF.png"></p><h1 id="前置处理器"><a href="#前置处理器" class="headerlink" title="前置处理器"></a>前置处理器</h1><h2 id="用户参数"><a href="#用户参数" class="headerlink" title="用户参数"></a>用户参数</h2><p>无论用户参数和用户定义的变量这两个变量放置的位置在哪，都有：用户定义的变量是全局的，所有线程可用；用户参数是局部的，同一线程组下可用</p><p><img src="/image/image_GyrO2xFhhX.png"></p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="同步定时器"><a href="#同步定时器" class="headerlink" title="同步定时器"></a>同步定时器</h2><p>与线程组的线程数配合使用。可用于设置集合点，模拟多用户并发</p><p><img src="/image/image_RyOdnfg6Bm.png"></p><p>使用用表格查看结果树可以更清晰地看到是否并发访问</p><p><img src="/image/image_l9IoyOB4Xv.png"></p><h2 id="固定定时器"><a href="#固定定时器" class="headerlink" title="固定定时器"></a>固定定时器</h2><p>间隔指定时间后执行后面的请求，常用于模拟用户的思考时间</p><h1 id="取样器"><a href="#取样器" class="headerlink" title="取样器"></a>取样器</h1><h2 id="HTTP取样器"><a href="#HTTP取样器" class="headerlink" title="HTTP取样器"></a>HTTP取样器</h2><p><img src="/image/%E6%97%A0%E6%A0%87%E9%A2%98_wRdZye1EZw.png"></p><h2 id="调试取样器"><a href="#调试取样器" class="headerlink" title="调试取样器"></a>调试取样器</h2><h2 id="BeanShell取样器"><a href="#BeanShell取样器" class="headerlink" title="BeanShell取样器"></a>BeanShell取样器</h2><p>BeanShell取样器可以理解为一个小型的Java解释器</p><p>常用脚本</p><table><thead><tr><th>${变量名};</th><th>在请求处可看到此变量的值</th></tr></thead><tbody><tr><td>ResponseMessage&#x3D;”${变量名}”</td><td>在响应处可看到此变量的值</td></tr><tr><td>${__setProperty(变量名,变量值,)}</td><td>设置一个全局变量，但是调用时必须用property函数调用。如果变量值填写一个局部变量，则可将一个局部变量设置为全局变量</td></tr><tr><td>${__property(变量名,,)}</td><td>调用setProperty定义的全局变量</td></tr></tbody></table><h1 id="后置处理器"><a href="#后置处理器" class="headerlink" title="后置处理器"></a>后置处理器</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>一般格式：left(元字符+限定符)right</p><p><strong>元字符</strong></p><table><thead><tr><th>元字符</th><th>意义</th></tr></thead><tbody><tr><td>.</td><td>任意单个字符</td></tr><tr><td>\d</td><td>任意单个数字</td></tr><tr><td>[0-9]</td><td>0至9之间的任意一个</td></tr><tr><td>[a-zA-Z]</td><td>a至z或A-Z之间的任意一个</td></tr></tbody></table><p><strong>限定符</strong></p><table><thead><tr><th>限定符</th><th>意义</th></tr></thead><tbody><tr><td>+</td><td>匹配至少大于1次</td></tr><tr><td>？</td><td>遇到第一个右边界停止，如果不加会在遇到换行符前的最后一个右边界停止</td></tr><tr><td>*</td><td>匹配0次或多次，贪婪匹配</td></tr><tr><td>{n,}、{n,m}、{n}</td><td>匹配限定次数</td></tr></tbody></table><p>验证匹配是否正确可以在“查看结果树”的正则表达式测试或去在线正则表达式网站测试</p><h2 id="正则表达式提取器"><a href="#正则表达式提取器" class="headerlink" title="正则表达式提取器"></a>正则表达式提取器</h2><p>如果想在某个请求的响应结果里面拿到某个值，可以使用后置处理器中的正则表达式提取器</p><p>步骤</p><ol><li><p>确定左右边界</p></li><li><p>写正则表达式，常用left(.*?)right</p></li></ol><p><img src="/image/image_A0Q29AevyN.png"></p><h2 id="json提取器"><a href="#json提取器" class="headerlink" title="json提取器"></a>json提取器</h2><p><img src="/image/image_ZmIAxY2ldj.png"></p><table><thead><tr><th>Names of created variables</th><th>接收提取值的变量名，此变量不能跨线程使用</th></tr></thead><tbody><tr><td>JSON Path expression</td><td>json path 表达式</td></tr><tr><td>Match No.(0 for Random)</td><td>取第几个值&amp;#xA;0：随机，<strong>默认</strong>&amp;#xA;-1：所有&amp;#xA;1：第一个值</td></tr><tr><td>Compute concatenation var(suffix_ALL)</td><td>勾选后，如果匹配到多个值，则将它们都连接起来，不同值之间用 , 分隔；变量会在原来基础上自动添加_ALL的后缀</td></tr><tr><td>Default Values</td><td>匹配不到值的时候取该值，可写error</td></tr></tbody></table><p>多个json path表达式用分号（；）隔开，此时参数名、匹配数字和默认值应当与json path表达式一一对应，且都是用分号隔开。</p><p><strong>json path表达式格式：</strong></p><ol><li><p>$代表根目录</p></li><li><p>取得键对应的值</p><p>$[“键名”]</p><p>$.键名</p></li><li><p>如果键的值是一个列表，可使用索引取得列表元素</p><p>$.键名[索引]</p><p>注意列表索引从0开始</p></li></ol><p><strong>获取多个数据的2种方法</strong>：</p><table><thead><tr><th>$.键名[*]</th><th>提取列表中的所有元素</th></tr></thead><tbody><tr><td>$..键名</td><td>提取所有层级下指定键的值</td></tr></tbody></table><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>用于检查测试中得到的响应数据等是否符合预期</p><p>使用断言的目的：在request的返回层面增加一层判断机制，因为request成功了，不代表结果一定正确，通过断言可以看到请求是否真的成功</p><h2 id="响应断言"><a href="#响应断言" class="headerlink" title="响应断言"></a>响应断言</h2><p><img src="/image/image_vFgJ9g3Oyt.png"></p><ol><li><p>apply to：通常发出一个请求只触发一个请求，所以勾选“main sampie only”就可以；若发一个请求可以触发多个服务器请求，就有main sample 和sub-sample之分了。另外，如果发起重定向请求，并且勾选“跟随重定向”， 则把重定向后的请求视为main-sample</p></li><li><p>测试字段：<br>(1)一般的http响应，都勾选“响应文本”；<br>(2)url样本是对sample的url进行断言，如果请求没有重定向，就请求url，如果有重定向，就请求url和重定向url；<br>(3)响应代码：http响应代码，如101,200,302,404,501等。当我们要验证4xx,5xx的http响应代码时，<strong>需要勾选“忽略状态</strong>（ ignore status）”。因为当http 响应代码为400,500时，jmeter默认这个请求时失败的；<br>(4)响应信息：响应代码对应得响应信息，例如“OK”</p></li><li><p>模式匹配：<br>(1)包括：返回结果包括你指定的内容，支持正则匹配<br>(2)匹配： 相当于 equals 。当返回值固定时，可以返回值做断言，效果和equals相同 ；<br>正则匹配 。 用正则表达式匹配返回结果，但必须全部匹配。 即正则表达式必须能匹配整个返回值，而不是返回值的一部分。<br>(3) SubString：与 “包括”差不多，都是指返回结果包括你指定的内容，但是subString不支持正则字符串<br>(4) 否：就相当于取反。 如果断言结果为true，勾选“否”后，最终断言结果为false。如果断言结果为false，勾选“否”后，则最终断言结果为 true</p></li><li><p>测试模式：输入结果期望值（空格要去掉）</p></li></ol><p>注意，在jmeter的察看结果树处，应该选择Text形式，而不能选择JSON格式，JSON格式方便查看但是不能匹配</p><h2 id="大小断言"><a href="#大小断言" class="headerlink" title="大小断言"></a>大小断言</h2><p><img src="/image/image__7ITWGy_OR.png"></p><h2 id="断言响应时间"><a href="#断言响应时间" class="headerlink" title="断言响应时间"></a>断言响应时间</h2><p>从请求到返回数据的时间，如果超过设定的时间则失败</p><p><img src="/image/image_tXMJikUz1M.png"></p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><h2 id="查看结果树"><a href="#查看结果树" class="headerlink" title="查看结果树"></a>查看结果树</h2><ul><li><p>css选择器</p></li><li><p>HTML</p></li><li><p>JSON</p></li><li><p>Document</p></li><li><p>Regexp_Tester（测试正则表达式）</p></li><li><p>XPath Tester</p></li></ul><h2 id="以表格查看结果数"><a href="#以表格查看结果数" class="headerlink" title="以表格查看结果数"></a>以表格查看结果数</h2><p><img src="/image/image_VlmH4QVYXB.png"></p><p>Sample#：编号类似id</p><p>Start Time：开始时间</p><p>Thread Name：线程名称</p><p>Label：请求名称</p><p>Sample Time：取样时间ms</p><p>Status：状态</p><p>Bytes：接受字节数</p><p>Sent Bytes：发送字节数</p><p>Latency：等待时间</p><p>Connect Time：链接时间</p><h2 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h2><p><img src="/image/image_mPBJf3saoP.png"></p><ol><li><p>Label:在不勾选”Include group name in label?”复选框的情况下，为请求取样器的名称，否则为“请求取样器所在线程组:请求取样器名称”</p></li><li><p>Samples:用同一个请求取样器，发送请求的数量(注意：该值是不断累计的)。比如，10个线程数设置为10，循环10次，那么每运行一次测试，该值就增加10*10&#x3D;100，只要没有清除结果</p></li><li><p>Average:请求的平均响应时间</p></li><li><p>Median:中位数。50%的样本都没有超过这个时间。这个值是指把所有数据按由小到大将其排列，就是排列在第50%的值。</p></li><li><p>90% Line：90%的样本都没有超过这个时间。这个值是指把所有数据按由小到大将其排列，就是排列在第90%的值。</p></li><li><p>Min:针对同一请求取样器，请求样本的最小响应时间</p></li><li><p>Max:针对同一请求取样器，请求样本的最大响应时间</p></li><li><p>Error %:出现错误的请求样本的百分比</p></li><li><p>Throughput：吞吐量以“requests&#x2F;second、requests &#x2F;minute、requests &#x2F;hour来衡量。时间单位已经被选取为second，所以，显示速率至少是1.0，即每秒1个请求。</p></li><li><p>Received KB&#x2F;sec - 收到的千字节每秒的吞吐量测试。</p></li><li><p>Kb&#x2F;sec - 以Kilobytes&#x2F;seond来衡量的吞吐量(发送的千字节每秒的吞吐量测试)</p></li></ol><h1 id="逻辑控制器"><a href="#逻辑控制器" class="headerlink" title="逻辑控制器"></a>逻辑控制器</h1><h2 id="ForEach控制器"><a href="#ForEach控制器" class="headerlink" title="ForEach控制器"></a>ForEach控制器</h2><p>循环使用后缀按索引变化的变量</p><p><img src="/image/image_g9ADsLwYTl.png"></p><h2 id="如果（if）控制器"><a href="#如果（if）控制器" class="headerlink" title="如果（if）控制器"></a>如果（if）控制器</h2><p>满足指定的条件才会执行其下的请求</p><p><img src="/image/image_TZnvIq2b1G.png"></p><h2 id="交替控制器"><a href="#交替控制器" class="headerlink" title="交替控制器"></a>交替控制器</h2><p>与线程组的循环配合使用，每次循环会按从上到下顺序依次执行其下的请求</p><h2 id="循环控制器"><a href="#循环控制器" class="headerlink" title="循环控制器"></a>循环控制器</h2><p>将其下的请求循环指定的次数</p><p><img src="/image/image_Md2CXYkPlG.png"></p><h2 id="While控制器"><a href="#While控制器" class="headerlink" title="While控制器"></a>While控制器</h2><p>条件为真时继续循环，条件为假时跳出循环</p><p><img src="/image/image_OLyELacw8m.png"></p><h2 id="仅一次控制器"><a href="#仅一次控制器" class="headerlink" title="仅一次控制器"></a>仅一次控制器</h2><p>与线程组的循环配合使用，当线程组的循环大于1次时，“仅一次控制器”下的组件只会在第一次时候执行一次</p><h2 id="随机控制器"><a href="#随机控制器" class="headerlink" title="随机控制器"></a>随机控制器</h2><p>随机执行其下的请求</p><h2 id="事务控制器"><a href="#事务控制器" class="headerlink" title="事务控制器"></a>事务控制器</h2><p>其下的请求是完成某个事务的一组请求，再聚合报告中会单独列出来</p><h1 id="jmeter结合fiddler"><a href="#jmeter结合fiddler" class="headerlink" title="jmeter结合fiddler"></a>jmeter结合fiddler</h1><p>jmeter的http请求中设置代理</p><p><img src="/image/image-20220224170046340_oF7ZNfJZXf.png"></p><p>利用fiddler截获http请求能更清楚的查看http报文的情况</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>打开函数助手</p><p><img src="/image/image_3QXKhlJRIc.png"></p><p>或</p><p><img src="/image/image_yuIgAOprW4.png"></p><p>函数助手的使用</p><p><img src="/image/image_6lfOFBqWTx.png"></p><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>返回指定范围内的随机整数，可以重复</p><p><img src="/image/image_TWTrp0FOPZ.png"></p><h2 id="RandomString"><a href="#RandomString" class="headerlink" title="RandomString"></a>RandomString</h2><p>从自定字符串中随机组合成指定长度的字符串，有可能会有重复</p><p><img src="/image/image_IZ_QLH2bse.png"></p><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>返回值从1开始，每次循环会加1。如果第一个参数为FALSE，意味着不同线程也会加1；如果为TRUE，意味着每个用户独立计数</p><p><img src="/image/image_6DhOxDrcX0.png"></p><h2 id="setProperty和property"><a href="#setProperty和property" class="headerlink" title="setProperty和property"></a>setProperty和property</h2><p>使用这两个函数可以将局部变量（仅在线程组内使用）转换为全局变量（可跨线程组使用），全局变量也成为属性，可在测试计划中右键添加属性显示来查看</p><p><img src="/image/image_Pjz_uY9kKl.png"></p><p>setProprty定义全局变量（属性）</p><p><img src="/image/image_T27MLPHgTc.png"></p><p>定义好后需要将函数写入局部变量所在线程组的BeanShell取样器的脚本中</p><p><img src="/image/image_tCT1d7eUdt.png"></p><p>运行此线程后，可在属性显示中查看是否设置成功</p><p><img src="/image/image_PgTsj0pPQs.png"></p><p>property使用属性</p><p><img src="/image/image_ArdomnDQ9X.png"></p><p>在另一线程组中使用函数</p><p><img src="/image/image_AMsGZzz7_R.png"></p><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>首先在测试计划中添加连接MySQL的jar包</p><p><img src="/image/image_DwmYgiZWll.png"></p><h2 id="JDBC-Connection-Configuration"><a href="#JDBC-Connection-Configuration" class="headerlink" title="JDBC Connection Configuration"></a>JDBC Connection Configuration</h2><p><img src="/image/image_4vnDLf8tUR.png"></p><p><img src="/image/image_oD9xpC8Ery.png"></p><h2 id="JDBC-Request"><a href="#JDBC-Request" class="headerlink" title="JDBC Request"></a>JDBC Request</h2><p><img src="/image/image_K96NG-VL6U.png"></p><h1 id="生成测试报告"><a href="#生成测试报告" class="headerlink" title="生成测试报告"></a>生成测试报告</h1><p>使用jmeter命令可以自动生成测试报告</p><h2 id="自带的性能测试报告"><a href="#自带的性能测试报告" class="headerlink" title="自带的性能测试报告"></a>自带的性能测试报告</h2><ol><li><p>打开cmd，进入jmeter目录下的bin目录下，可在目录下的路径栏直接输入cmd，回车，进入cmd后就是在当前目录下了</p><p><img src="/image/image_ur2M4Xqqz0.png"></p><p><img src="/image/image_CEFN9KWjzO.png"></p><p><img src="/image/image_CFUq18OSe-.png"></p></li><li><p>此时有两种命令可生成测试报告</p><p>方法一，将查看结果树的结果保存在一个文件中，后缀为jtl</p><p><img src="/image/image_PDHucOWw4J.png"></p><p>在cmd中（当前路径需在jmeter的bin目录下）运行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmeter -g 结果（jtl文件）路径 -o 报告输出目录（必须是空目录）<br></code></pre></td></tr></table></figure><p><img src="/image/image_1gh7gkNXmY.png"></p><p>方法二：使用命令执行jmx文件，然后生成结果和报告</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmeter -n -t jmx文件路径 -l 结果文件存放路径（自定义文件名称） -e -o 报告输出目录（必须是空目录）<br></code></pre></td></tr></table></figure><p><img src="/image/image_y3kvcwlZTp.png"></p></li></ol><h2 id="使用ant插件生成"><a href="#使用ant插件生成" class="headerlink" title="使用ant插件生成"></a>使用ant插件生成</h2><p>下载ant应用，转移插件，配置好jmeter.properties和build.xml文件。在含有build.xml的目录下打开cmd，输入ant命令</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
